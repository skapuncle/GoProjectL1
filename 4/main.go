package main

import (
	"fmt"
	"os"
	"os/signal"
	"syscall"
)

func main() {
	// Создаем канал для передачи данных.
	dataChannel := make(chan int)
	// Определяем количество воркеров.
	N := 0

	// Считываем количество воркеров из ввода пользователя.
	fmt.Scanln(&N)

	// Запускаем в новой горутине функцию writer.
	go writer(dataChannel)

	// Создаем указанное количество воркеров
	// Для каждого воркера запускаем функцию reader(dataChannel) в отдельной горутине
	for i := 0; i < N; i++ {
		go reader(dataChannel)
	}

	// Создаем канал для получения сигналов от ОС
	sigs := make(chan os.Signal)

	// Устанавливаем обработчик сигналов для канала sigs
	signal.Notify(sigs, os.Interrupt, syscall.SIGINT)
	// Ожидаем получения сигнала завершения работы
	<-sigs
	// Выводим сообщение о завершении работы и завершаем программу с кодом выхода 0
	fmt.Println("Shutting down...")
	os.Exit(0)
}

// Функция для записи данных в канал
func writer(dc chan int) {
	i := 0
	// Бесконечно увеличивает значение переменной i и отправляет его в канал
	for {
		dc <- i
		i++
	}
}

// Функция, которая читает данные из канала dc и выводит их на экран
func reader(dc chan int) {
	for data := range dc {
		fmt.Println(data)
	}
}

//В этом коде используется способ, который позволяет остановить работу программы
//при получении сигнала os.Interrupt (Ctrl+C). Когда этот сигнал получен,
//программа выводит сообщение "Shutting down..." и немедленно останавливает работу.
//Это приводит к остановке всех рабочих потоков, включая потоки,
//которые записывают данные в канал (writer) и читают данные из канала (reader).
//Программа останавливает работу с помощью os.Exit(0), что гарантирует прекращение
//работы всех рабочих потоков, включая воркеров, без необходимости ожидания их завершения.
